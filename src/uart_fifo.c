/*  File: uart_fifo.c
 *  Author: Auto-generated by mkqueue.py
 */

#include "uart_fifo.h"
#include "marble_api.h"
#include "console.h"

#define BLOCK_TX_ON_FULL
#define USART_TX_RETRY_TIMEOUT_MS   (1000)

// ============================= Private Typedefs ==============================
typedef struct {
  uint8_t pIn;
  uint8_t pOut;
  uint8_t full;
  uint8_t queue[UART_QUEUE_ITEMS];
} UART_queue_t;

typedef struct {
  uint32_t pIn;
  uint32_t pOut;
  uint8_t full;
  uint8_t queue[UARTTX_QUEUE_ITEMS];
} UARTTX_queue_t;

// ============================ Private Prototypes =============================
static int _USART_Tx_RetryOnEmpty(uint8_t *c);
#ifdef UART_ECHO
static void USART_Erase_Echo(void);
static void USART_Erase(int n);
#endif

// ============================= Private Variables =============================
static UART_queue_t UART_queue;
static UARTTX_queue_t UARTTX_queue;
static uint8_t _dataLost = UART_DATA_NOT_LOST;

// =========================== Function Definitions ============================
void UARTQUEUE_Init(void) {
  UART_queue.pIn = 0;
  UART_queue.pOut = 0;
  UART_queue.full = 0;
  _dataLost = 0;
  UARTTX_queue.pIn = 0;
  UARTTX_queue.pOut = 0;
  UARTTX_queue.full = 0;
  return;
}

void UARTQUEUE_Clear(void) {
  UART_queue.pIn = 0;
  UART_queue.pOut = 0;
  UART_queue.full = 0;
  return;
}

uint8_t UARTQUEUE_Add(uint8_t *item) {
  // If full, return error
  if (UART_queue.full) {
    return UART_QUEUE_FULL;
  }
  // Copy item into queue
  for (unsigned int n = 0; n < sizeof(uint8_t); n++) {
    *((uint8_t *)&(UART_queue.queue[UART_queue.pIn]) + n) = *((uint8_t *)item + n);
  }
  // Wrap pIn at boundary
  if (UART_queue.pIn == UART_QUEUE_ITEMS - 1) {
    UART_queue.pIn = 0;
  } else {
    UART_queue.pIn++;
  }
  // Check for full condition
  if (UART_queue.pIn == UART_queue.pOut) {
    UART_queue.full = 1;
  }
  return UART_QUEUE_OK;
}

/*
 * Like _Get but removes the newest (last-added) item rather than the oldest item
 */
uint8_t UARTQUEUE_Pop(uint8_t *item) {
  // Check for empty queue
  if ((UART_queue.pIn == UART_queue.pOut) && (UART_queue.full == 0)) {
    return UART_QUEUE_EMPTY;
  }
  // Rewind pIn and wrap at boundary
  if (UART_queue.pIn == 0) {
    UART_queue.pIn = UART_QUEUE_ITEMS - 1;
  } else {
    UART_queue.pIn--;
  }
  // Copy newest data from the queue to item
  for (unsigned int n = 0; n < sizeof(uint8_t); n++) {
    *((uint8_t *)item + n) = *((uint8_t *)&(UART_queue.queue[UART_queue.pIn]) + n);
  }
  // Clear full condition
  UART_queue.full = 0;
  return UART_QUEUE_OK;
}

/*
 * Pop and discard the newest 'n' entries
 */
uint8_t UARTQUEUE_Rewind(int n) {
  // No-op if n=0
  if (n == 0) {
    return UART_QUEUE_OK;
  }
  // Check for empty queue
  if ((UART_queue.pIn == UART_queue.pOut) && (UART_queue.full == 0)) {
    return UART_QUEUE_EMPTY;
  }
  // n = min(n, fill-level)
  int fill = UARTQUEUE_FillLevel();
  n = n > fill ? fill : n;
  // Rewind pIn and wrap at boundary
  if ((uint8_t)n > UART_queue.pIn) {
    UART_queue.pIn = UART_QUEUE_ITEMS - ((uint8_t)n - UART_queue.pIn);
  } else {
    UART_queue.pIn -= (uint8_t)n;
  }
  // Clear full condition
  UART_queue.full = 0;
  return UART_QUEUE_OK;
}

uint8_t UARTQUEUE_Get(volatile uint8_t *item) {
  // Check for empty queue
  if ((UART_queue.pIn == UART_queue.pOut) && (UART_queue.full == 0)) {
    return UART_QUEUE_EMPTY;
  }
  // Copy next data from the queue to item
  for (unsigned int n = 0; n < sizeof(uint8_t); n++) {
    *((volatile uint8_t *)item + n) = *((volatile uint8_t *)&(UART_queue.queue[UART_queue.pOut]) + n);
  }
  // Wrap pOut at boundary
  if (UART_queue.pOut == UART_QUEUE_ITEMS - 1) {
    UART_queue.pOut = 0;
  } else {
    UART_queue.pOut++;
  }
  // Clear full condition
  UART_queue.full = 0;
  return UART_QUEUE_OK;
}

uint8_t UARTQUEUE_Status(void) {
  if ((UART_queue.pIn == UART_queue.pOut) && (UART_queue.full == 0)) {
    return UART_QUEUE_EMPTY;
  }
  if (UART_queue.full) {
    return UART_QUEUE_FULL;
  }
  // If not full or empty, it is non-empty (at least one item in queue)
  return UART_QUEUE_OK;
}

/*
 * int UARTQUEUE_ShiftOut(uint8_t *pData, int len);
 *  Shift up to 'len'
 */
int UARTQUEUE_ShiftOut(uint8_t *pData, int len) {
  int nShifted = 0;
  uint8_t dataOut;
  while (UARTQUEUE_Get(&dataOut) != UART_QUEUE_EMPTY) {
    *(pData++) = dataOut;
    if (++nShifted == len) {
      break;
    }
  }
  return nShifted;
}

/*
 * int UARTQUEUE_ShiftUntil(uint8_t *pData, uint8_t target, int len);
 *  Shift until finding byte 'target' (up to 'len')
 */
int UARTQUEUE_ShiftUntil(uint8_t *pData, uint8_t target, int len) {
  int nShifted = 0;
  uint8_t dataOut;
  while (UARTQUEUE_Get(&dataOut) != UART_QUEUE_EMPTY) {
    *(pData++) = dataOut;
    if ((++nShifted == len) || (dataOut == target)) {
      break;
    }
  }
  return nShifted;
}

void UARTQUEUE_SetDataLost(uint8_t lost) {
  if (lost) {
    _dataLost = UART_DATA_LOST;
  }
  else {
    _dataLost = UART_DATA_NOT_LOST;
  }
  return;
}

uint8_t UARTQUEUE_IsDataLost(void) {
  return _dataLost;
}

/*
 * int UARTQUEUE_FillLevel(void);
 *    Return the number of items currently in the queue.
 */
int UARTQUEUE_FillLevel(void) {
  if (UART_queue.full) {
    return UART_QUEUE_ITEMS;
  } else if (UART_queue.pIn == UART_queue.pOut) {
    return 0;
  } else if (UART_queue.pIn > UART_queue.pOut) {
    return (int)(UART_queue.pIn - UART_queue.pOut);
  } else {
    return (int)(UART_QUEUE_ITEMS + UART_queue.pIn - UART_queue.pOut);
  }
}

uint8_t UARTTXQUEUE_Add(uint8_t *item) {
  // If full, return error
  if (UARTTX_queue.full) {
    return UARTTX_QUEUE_FULL;
  }
  // Copy item into queue
  for (unsigned int n = 0; n < sizeof(uint8_t); n++) {
    *((uint8_t *)&(UARTTX_queue.queue[UARTTX_queue.pIn]) + n) = *((uint8_t *)item + n);
  }
  // Wrap pIn at boundary
  if (UARTTX_queue.pIn == UARTTX_QUEUE_ITEMS - 1) {
    UARTTX_queue.pIn = 0;
  } else {
    UARTTX_queue.pIn++;
  }
  // Check for full condition
  if (UARTTX_queue.pIn == UARTTX_queue.pOut) {
    UARTTX_queue.full = 1;
  }
  return UARTTX_QUEUE_OK;
}

uint8_t UARTTXQUEUE_Get(volatile uint8_t *item) {
  // Check for empty queue
  if ((UARTTX_queue.pIn == UARTTX_queue.pOut) && (UARTTX_queue.full == 0)) {
    return UARTTX_QUEUE_EMPTY;
  }
  // Copy next data from the queue to item
  for (unsigned int n = 0; n < sizeof(uint8_t); n++) {
    *((volatile uint8_t *)item + n) = *((volatile uint8_t *)&(UARTTX_queue.queue[UARTTX_queue.pOut]) + n);
  }
  // Wrap pOut at boundary
  if (UARTTX_queue.pOut == UARTTX_QUEUE_ITEMS - 1) {
    UARTTX_queue.pOut = 0;
  } else {
    UARTTX_queue.pOut++;
  }
  // Clear full condition
  UARTTX_queue.full = 0;
  return UARTTX_QUEUE_OK;
}

uint8_t UARTTXQUEUE_Status(void) {
  if ((UARTTX_queue.pIn == UARTTX_queue.pOut) && (UARTTX_queue.full == 0)) {
    return UARTTX_QUEUE_EMPTY;
  }
  if (UARTTX_queue.full) {
    return UARTTX_QUEUE_FULL;
  }
  // If not full or empty, it is non-empty (at least one item in queue)
  return UARTTX_QUEUE_OK;
}

// ========================== Non- Blocking API ===============================

/*
 * int USART_Tx_LL_Queue(char *msg, int len);
 *    Returns number of bytes added to queue
 *    Returns -1 on full
 */
int USART_Tx_LL_Queue(char *msg, int len) {
  // Add to byte queue
  uint8_t rval;
  int n = 0;
  for (n = 0; n < len; n++) {
    rval = UARTTXQUEUE_Add((uint8_t *)(msg + n)); // Type uint8_t* (not char*)
    if (rval == UARTTX_QUEUE_FULL) {
#ifdef BLOCK_TX_ON_FULL
      // Wait for empty and attempt again
      if (_USART_Tx_RetryOnEmpty((uint8_t *)(msg + n)) == UARTTX_QUEUE_FULL) {
        // If still full after timeout, abort
        return -1;
      }
#else
      return -1;
#endif
    }
  }
  return n;
}

/*
 * static int _USART_Tx_RetryOnEmpty(uint8_t *c);
 *    Wait up to USART_TX_RETRY_TIMEOUT attempts for UARTTX_QUEUE to become
 *    non-full, then attempt to add 'c' to the queue.  Returns UARTTX_QUEUE_OK
 *    on success, UARTTX_QUEUE_FULL on failure.
 */
static int _USART_Tx_RetryOnEmpty(uint8_t *c) {
  uint32_t start = marble_get_tick();
  while ((marble_get_tick() - start) < USART_TX_RETRY_TIMEOUT_MS) {
    if (UARTTXQUEUE_Status() != UARTTX_QUEUE_FULL) {
      break;
    }
  }
  // If timeout expired, this should return UARTTX_QUEUE_FULL
  return UARTTXQUEUE_Add(c);
}

/*
 * int USART_Rx_LL_Queue(volatile char *msg, int len);
 *    Attempt to read 'len' characters from Rx queue into 'msg'
 *    Returns number of chars read from queue.
 */
int USART_Rx_LL_Queue(volatile char *msg, int len) {
  int n = 0;
  while (UARTQUEUE_Get((volatile uint8_t *)(msg + n)) != UART_QUEUE_EMPTY) {
    if (n++ >= len) {
      break;
    }
  }
  return n;
}

/*
 * void USART_RXNE_ISR(void);
 *  A low-level ISR to pre-empt the STM32_HAL handler to catch
 *  received bytes (TxE IRQ passes to HAL handler)
 */
void USART_RXNE_ISR(void) {
  uint8_t c = 0;
  if (CONSOLE_USART_RX_DATA_AVAILABLE()) {
    // Don't clear flags; the RXNE flag is cleared automatically by read from DR
    c = CONSOLE_USART_GET_RX_CHAR();
    // Look for control characters first
    if (c == UART_MSG_ABORT) {
#ifdef UART_ECHO
      USART_Erase_Echo();
#endif
      // clear queue
      UARTQUEUE_Clear();
    } else if (c == UART_MSG_BKSP) {
#ifdef UART_ECHO
      USART_Erase(1);
#endif
      UARTQUEUE_Rewind(1);
    } else {
      if ((c == UART_MSG_TERMINATOR) || (c == UART_ALT_MSG_TERMINATOR)) {
        if (UARTQUEUE_Status() != UART_QUEUE_EMPTY) {
          c = UART_MSG_TERMINATOR;
          //UARTQUEUE_Add(&c);
          //c = UART_ALT_MSG_TERMINATOR;
          if (UARTQUEUE_Add(&c) == UART_QUEUE_FULL) {
            UARTQUEUE_SetDataLost(UART_DATA_LOST);
            // Clear QUEUE at this point?
          }
          console_pend_msg();
        } else {
          // Don't print
          return;
        }
      } else {
        if (UARTQUEUE_Add(&c) == UART_QUEUE_FULL) {
          UARTQUEUE_SetDataLost(UART_DATA_LOST);
          // Clear QUEUE at this point?
        }
      }
#ifdef UART_ECHO
      marble_UART_send((const char *)&c, 1);
#endif
    }
  }
  return;
}

void USART_TXE_ISR(void) {
  uint8_t outByte;
  // Send more data if the queue is not empty
  if (CONSOLE_USART_TX_DATA_READY()) {
    if (UARTTXQUEUE_Get(&outByte) != UARTTX_QUEUE_EMPTY) {
      // Write new char to DR
      CONSOLE_USART_WRITE_TX_CHAR(outByte);
    } else {
      // If the queue is empty, disable the TXE interrupt
      CONSOLE_USART_DISABLE_TXE_IRQ();
    }
  }
  return;
}

#ifdef UART_ECHO
/*
 * void USART_Erase_Echo(void);
 *  Print 1 backspace for every char in the queue
 */
static void USART_Erase_Echo(void) {
  USART_Erase(0);
  return;
}

static void USART_Erase(int n) {
  int fill = UARTQUEUE_FillLevel();
  // If n = 0, erase all in queue
  if (n == 0) {
    n = fill;
  } else {
    // n = min(n, fill)
    n = n > fill ? fill : n;
  }
  // First issue backspaces
  char bksps[n];
  for (int m = 0; m < n; m++) {
    bksps[m] = UART_MSG_BKSP;
  }
  marble_UART_send((const char *)bksps, n);
  // Then overwrite with spaces
  for (int m = 0; m < n; m++) {
    bksps[m] = ' ';
  }
  marble_UART_send((const char *)bksps, n);
  // Then issue backspaces again
  for (int m = 0; m < n; m++) {
    bksps[m] = UART_MSG_BKSP;
  }
  marble_UART_send((const char *)bksps, n);
  return;
}
#endif // ifdef UART_ECHO

/* Send string over UART. Returns number of bytes sent */
int marble_UART_send(const char *str, int size)
{
  int txnum = USART_Tx_LL_Queue((char *)str, size);
  // Kick off the transmission if the TX buffer is empty
  if (CONSOLE_USART_TX_DATA_READY()) {
    CONSOLE_USART_ENABLE_TXE_IRQ();
  }
  return txnum;
}

int marble_UART_recv(char *str, int size) {
  return USART_Rx_LL_Queue((volatile char *)str, size);
}
