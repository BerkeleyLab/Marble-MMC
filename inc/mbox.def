# Bespoke-syntax mailbox definition file (JSON with comments)
#
# To generate #include statements in the source file, there should be one special
# key-value pair named "include" whose value is a list of file names to include
# (as strings).
#
# Every other key-value pair represents a page of the mailbox.
# Each page is a key-value pair where the key is 'pageN' where 1 <= N <= 128
# The value of the key-value pair is a list of dicts where each dict represents
# an entry in the mailbox whose address/index is inferred from its position in
# the list. Note that this requires dummy entries for unused addresses.

# Mailbox Element Dict Structure:
# -------------------------------
#   Mandatory Attributes:
#     Name      Type    Valid values        Desc
#     ------------------------------------------
#     name      string  *                   Mandatory name of mailbox entry
#
#   Optional Attributes:
#     Name      Type    Valid values        Desc
#     ------------------------------------------
#     type      string  "int", "float", "pointer" Data type to assist in interpreting the contents of the member
#     size      int     1,2,3,4             Number of bytes that make up element
#     output    string  *                   How to write the value to the mailbox (where does it come from)
#     input     string  *                   How to read the value from the mailbox (where does it go)
#     fmt       string  printf fmt string   Format string for data formatting/presentation.
#                                           Accepts both printf-style (e.g. '%x') and new Python format
#                                           strings (e.g. '{:x}')
#     desc      string  *                   Human-readable description of the data member (for documentation)
#     scale     float   *                   Multiply the value read from the mailbox by 'scale' to get
#                                           physical units (before handed to 'fmt')
#     ack       string  *                   Used to respond to mailbox reads (from FPGA) with a write.
#     respond   string  *                   Alias for 'ack'
#
#   Note: If 'size' param is >1, adjacent entries will be created with names 0 to size-1 (in MSB-to-LSB order)
#
#   Note: Any entry with a name that starts with 'PAD' will be treated as padding and will not be used.
#
#   type param:
#     If type=="pointer", the '@' character in the "input" or "output" attribute values will be replaced by
#     a (void *) pointer cast directly to the mailbox page struct while the '$' character will be replaced by
#     the size of the element.  This allows for handling values up to 16 bytes (size limited by mailbox page
#     size) simultaneously.  This type is required for 'size' > 4.
#     Example:
#       "page1" : [
#         { "name"  : "BAR",
#           "type"  : "pointer",
#           "size"  : 6,
#           "input" : "foo(@, $)"}
#       ]
#       Assumes a function exists with the signature: foo(void *, int)
#       Will generate: foo((void *)&page[MB1_BAR], 6);
#
#   input param:
#     The special character '@' will be replaced with the value read from the mailbox (and is thus an r-value).
#     Thus, to pass the value to function 'foo' as the first attribute, simply use "foo(@)".  To assign the
#     value to a global variable 'bar', use "bar = @"
#
#   output param:
#     The special character '@' will be replaced with the destination in the mailbox (and is thus an l-value).
#     If the value comes from the return value of function 'foo', use "@ = foo()"
#     If the value is read via a volatile argument to function bar, use "bar(&@)"
#
#   ack param:
#     The special character '@' will be replaced with the value read from the mailbox.  The resulting expression
#     is then evaluated and written to the same location in the mailbox.  This should only be used in a mailbox
#     page that contains only inputs (FPGA-to-MMC).  Otherwise, the respond value would be clobbered by a write
#     of zero immediately following the response (because reads and writes are done by page).
#
#   Note: If the lone keyword 'return' is found in either 'input' or 'output' attributes, it is flagged as a
#         syntax error since it would otherwise lead to hard-to-trace bugs.

# =============================================================================
# ======================== BEGIN MAILBOX DEFINITION ===========================
# =============================================================================
{
# Page 2 contains only inputs (MMC <= FPGA)
  "page2" : [
    { "name" : "FMC_MGT_CTL",
      "type" : "int",
      "fmt"  : "0x{:x}",
      "desc" : "Input is bitfield. See scripts/README.md mgtmux_mbox.sh.",
      "input" : "marble_MGTMUX_config(@, 0, 0)",
      "ack"  : "@ & 0x55"
    }
  ],
# Page 3 contains only outputs (MMC => FPGA)
  "page3" : [
    { "name" : "COUNT",
      "size" : 2,
      "type" : "int",
      "desc" : "Mailbox update counter",
      "fmt"  : "%d",
      "output" : "@ = mbox_get_update_count()"
    },
    { "name" : "PAD1"},
    { "name" : "PAD2"},
    { "name" : "LM75_0",
      "size" : 2,
      "type" : "float",
      "fmt"  : "{:.1f} degC",
      "scale": 0.5,
      "desc" : "Returns LM75_0 temperature in units of 0.5degC",
      "output" : "LM75_read(LM75_0, LM75_TEMP, (int *)&@)"
    },
    { "name" : "LM75_1",
      "size" : 2,
      "type" : "float",
      "fmt"  : "{:.1f} degC",
      "scale": 0.5,
      "desc" : "Returns LM75_1 temperature in units of 0.5degC",
      "output" : "LM75_read(LM75_1, LM75_TEMP, (int *)&@)"
    },
    { "name" : "FMC_ST",
      "type" : "int",
      "fmt"  : "",
      "output"  : "@ = marble_FMC_status()",
      "desc" : "Returns bitfield. 0=FMC1_PWR, 1=FMC1_FUSE, 2=FMC2_PWR, 3=FMC1_FUSE"
    },
    { "name" : "PWR_ST",
      "type" : "int",
      "fmt"  : "",
      "output"  : "@ = marble_PWR_status()",
      "desc" : "Returns bitfield. 0=PSU_EN, 1=~POE_PRESENT, 2=OTEMP"
    },
    { "name" : "MGTMUX_ST",
      "type" : "int",
      "fmt"  : "",
      "output"  : "@ = marble_MGTMUX_status()",
      "desc" : "Returns bitfield of mux pin states. 0=MUX0_MMC, 1=MUX1_MMC, 2=MUX2_MMC"
    },
    { "name" : "PAD3"
    },
    { "name" : "GIT32",
      "type" : "int",
      "size" : 4,
      "fmt"  : "{:08X}",
      "output" : "@ = GIT_REV_32BIT",
      "desc" : "32-bit git commit ID"
    }
  ],
# Page 4 contains only outputs (MMC => FPGA)
  "page4" : [
    { "name" : "MAX_T1_HI",
      "output" : "@ = return_max6639_reg(MAX6639_TEMP_CH1)",
      "desc" : "Returns raw value of MAX6639 register TEMP_CH1"
    },
    { "name" : "MAX_T1_LO",
      "output" : "@ = return_max6639_reg(MAX6639_TEMP_EXT_CH1)",
      "desc" : "Returns raw value of MAX6639 register TEMP_EXT_CH1"
    },
    { "name" : "MAX_T2_HI",
      "output" : "@ = return_max6639_reg(MAX6639_TEMP_CH2)",
      "desc" : "Returns raw value of MAX6639 register TEMP_CH2"
    },
    { "name" : "MAX_T2_LO",
      "output" : "@ = return_max6639_reg(MAX6639_TEMP_EXT_CH2)",
      "desc" : "Returns raw value of MAX6639 register TEMP_EXT_CH2"
    },
    { "name" : "MAX_F1_TACH",
      "output" : "@ = return_max6639_reg(MAX6639_FAN1_TACH_CNT)",
      "desc" : "Returns raw value of MAX6639 register FAN1_TACH_CNT"
    },
    { "name" : "MAX_F2_TACH",
      "output" : "@ = return_max6639_reg(MAX6639_FAN2_TACH_CNT)",
      "desc" : "Returns raw value of MAX6639 register FAN2_TACH_CNT"
    },
    { "name" : "MAX_F1_DUTY",
      "output" : "@ = return_max6639_reg(MAX6639_FAN1_DUTY)",
      "desc" : "Returns MAX6639 ch1 fan duty cycle as duty_percent*1.2.",
      "scale": 0.833333,
      "fmt"  : "{:.1f} %"
    },
    { "name" : "MAX_F2_DUTY",
      "output" : "@ = return_max6639_reg(MAX6639_FAN2_DUTY)",
      "desc" : "Returns MAX6639 ch2 fan duty cycle as duty_percent*1.2.",
      "scale"  : 0.833333,
      "fmt"  : "{:.1f} %"
    },
    {
      "name" : "PCB_REV",
      "output" : "@ = marble_get_board_id()",
      "desc" : "Returns bitfield. [4:7]=Board type (0=sim, 1=marble, 2=mini), [0:3]=PCB rev",
      "fmt"  : "0x{:x}"
    },
    { "name" : "COUNT",
      "size" : 2,
      "type" : "int",
      "desc" : "Mailbox update counter",
      "fmt"  : "%d",
      "output" : "@ = mbox_get_update_count()"
    }
  ],
# Page 5 contains both inputs and outputs (MMC <=> FPGA)
  "page5" : [
    { "name" : "I2C_BUS_STATUS",
      "type" : "int",
      "fmt"  : "0b{:b}",
      "output": "@ = (uint8_t)getI2CBusStatus()",
      "input" : "mbox_handleI2CBusStatusMsg(@)",
      "desc" : "Returns logical OR of all I2C function return values. Write nonzero value to clear status."
    }
  ],

# Page 16 is beginning of Pmod forwarder
  "page16" : [
    { "name" : "PMOD_CR0",
      "type" : "pointer",
      "size" : 16,
      "fmt"  : "0b{:b}",
      "input": "pmodf_handleConfig0(@, $)",
      "desc" : "Pmod Forwarder configuration register 0 (CR0)"
    }
  ],
  "page17" : [
    { "name" : "PMOD_DATA_PAGE0",
      "type" : "pointer",
      "size" : 16,
      "fmt"  : "0b{:b}",
      "input": "pmodf_handleData0(@, $)",
      "ack"  : "pmodf_returnData0(@, $)",
      "desc" : "Pmod Forwarder data page 0 (DATA_PAGE0)"
    }
  ]
}


# =============================================================================
# ========================== END MAILBOX DEFINITION ===========================
# =============================================================================
